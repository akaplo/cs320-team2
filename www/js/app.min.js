'use strict';

// Ionic Starter App

// angular.module is a global place for creating, registering and retrieving Angular modules
// 'starter' is the name of this angular module example (also set in a <body> attribute in index.html)
// the 2nd parameter is an array of 'requires'
// 'starter.services' is found in services.js
// 'starter.controllers' is found in controllers.js
angular.module('starter', ['ionic', 'starter.controllers', 'starter.services']).run(function ($ionicPlatform) {
  $ionicPlatform.ready(function () {
    // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
    // for form inputs)
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
      cordova.plugins.Keyboard.disableScroll(true);
    }
    if (window.StatusBar) {
      // org.apache.cordova.statusbar required
      StatusBar.styleDefault();
    }
  });
}).config(function ($stateProvider, $urlRouterProvider) {

  // Ionic uses AngularUI Router which uses the concept of states
  // Learn more here: https://github.com/angular-ui/ui-router
  // Set up the various states which the app can be in.
  // Each state's controller can be found in controllers.js
  $stateProvider

  // setup an abstract state for the tabs directive
  .state('tab', {
    url: '/tab',
    abstract: true,
    templateUrl: 'templates/tabs.html'
  })

  // Each tab has its own nav history stack:

  .state('tab.dash', {
    url: '/dash',
    views: {
      'tab-dash': {
        templateUrl: 'templates/tab-dash.html',
        controller: 'DashCtrl'
      }
    }
  }).state('tab.preferences', {
    url: '/preferences',
    views: {
      'tab-preferences': {
        templateUrl: 'templates/tab-preferences.html',
        controller: 'PreferencesCtrl'
      }
    }
  }).state('tab.account', {
    url: '/account',
    views: {
      'tab-account': {
        templateUrl: 'templates/tab-account.html',
        controller: 'AccountCtrl'
      }
    }
  }).state('tab.get-help', {
    url: '/get-help',
    views: {
      'tab-get-help': {
        templateUrl: 'templates/tab-get-help.html',
        controller: 'GetHelpCtrl'
      }
    }
  }).state('tab.track-progress', {
    url: '/track-progress',
    views: {
      'tab-track-progress': {
        templateUrl: 'templates/tab-track-progress.html',
        controller: 'TrackProgressCtrl'
      }
    }
  }).state('tab.progress-detail', {
    url: '/track-progress/progress-detail',
    views: {
      'tab-progress-detail': {
        templateUrl: 'templates/tab-progress-detail.html',
        controller: 'ProgressDetailCtrl'
      }
    },
    params: { mood: null }
  });

  // if none of the above states are matched, use this as the fallback
  $urlRouterProvider.otherwise('/tab/dash');
});
'use strict';

angular.module('starter.controllers', []).controller('DashCtrl', function ($scope) {})
// With the new view caching in Ionic, Controllers are only called
// when they are recreated or on app start, instead of every page change.
// To listen for when this page is active (for example, to refresh data),
// listen for the $ionicView.enter event:
//
//$scope.$on('$ionicView.enter', function(e) {
//});

.controller('PreferencesCtrl', function ($scope) {
  $scope.preferences = {};
  $scope.preferences.userName = "TODO:  CALL TO DATABASE!!!!";
  $scope.preferences.password = "TODO:  CALL TO DATABASE!!!!";
  $scope.preferences.helpContact = "TODO:  CALL TO DATABASE!!!!";
  $scope.preferences.splashScreen = "https://s3.amazonaws.com/codecademy-blog/assets/puppy-main_zps26d178c5.jpg"; //TODO:  Call to database!

  // Let the user select their reminder rate.
  // Fetch previous state.
  $scope.preferences.reminderRate = Infinity; //TODO:  Call to database!
  // Build a table of the reminder rates allowed.
  $scope.preferences.REMINDER_RATE_VALS = {};
  $scope.preferences.REMINDER_RATE_VALS["Twice A Day"] = 12 * 60 * 60 * 1000;
  $scope.preferences.REMINDER_RATE_VALS["Once A Day"] = 24 * 60 * 60 * 1000;
  $scope.preferences.REMINDER_RATE_VALS["Once A Week"] = 7 * 24 * 60 * 60 * 1000;
  $scope.preferences.REMINDER_RATE_VALS["Never"] = Infinity;
  // Build the list that will be displayed.
  $scope.preferences.selectedReminderString = "Time is an illusion.";
  $scope.preferences.unselectedReminderStrings = [];
  for (var x in $scope.preferences.REMINDER_RATE_VALS) {
    if ($scope.preferences.reminderRate === $scope.preferences.REMINDER_RATE_VALS[x]) {
      $scope.preferences.selectedReminderString = x;
    }
    $scope.preferences.unselectedReminderStrings.push(x);
  }

  // Build functions.
  $scope.preferences.apply = function () {
    console.log('TODO:  Put in database userName = ' + $scope.preferences.userName);
    console.log('TODO:  Put in database password = ' + $scope.preferences.password);
    console.log('TODO:  Put in database contact = ' + $scope.preferences.helpContact);
    console.log('TODO:  Put in database splashScreen = ' + $scope.preferences.splashScreen);
    console.log('TODO:  Put in database reminder rate = ' + $scope.preferences.REMINDER_RATE_VALS[$scope.preferences.selectedReminderString]);
  };
  $scope.preferences.deleteAll = function () {
    if (confirm('Are you sure?  If you delete your mood logs, they are gone.  This action cannot be undone!')) {
      console.log('TODO:  Delete all mood logs in the database!');
    }
  };
}).controller('AccountCtrl', function ($scope) {
  $scope.settings = {
    enableFriends: true
  };
}).controller('GetHelpCtrl', function ($scope) {
  $scope.help = "no help yet yo";
});
'use strict';

app.controller('TrackProgressCtrl', function ($scope, $state) {
  console.log('aaa');
  $scope.showMood = function (moodType) {

    $state.go('tab.progress-detail', { mood: moodType });
  };
}).controller('ProgressDetailCtrl', function ($scope, $stateParams, Moods) {});
'use strict';

angular.module('starter.services', []).factory('GetHelp', function () {

	/* Proposed IDs associated with moods
 Mood        ID
 Anger		0
    Disgust		1
    Fear		2
    Happiness	3
    Sadness		4
    Surprise	5
 */

	/*
 //Proposed constructor for feedback objects
 function feedback(copingStrategy, response) {
 	//response === 1 if user responded 'yes' to the copingStrategy
 	//response === 0 if user responded 'no' to the copingStrategy
 	this.copingStrategy = copingStrategy;
 	this.response = response;
 }
 */

	//Get latest mood log
	//Will be retrieved from database once it is setup
	var latestMoodLog = null;

	//Get all feedback about coping strategies
	//Assume allFeedback is an array of feedback objects
	//Will be retrieved from database once it is setup
	var allFeedback = null;

	//Coping strategies for anger
	var angerStrats = ["Go to the gym", "Go for a walk"];

	//Coping strategies for disgust
	var disgustStrats = ["Speak with a trusted family member about your day", "Take a bath"];

	//Coping strategies for fear
	var fearStrats = ["Call a family member or friend", "Surround yourself with friends"];

	//Coping strategies for happiness
	var happinessStrats = ["Keep being happy!", "Continue doing what made you happy in the first place!"];

	//Coping strategies for sadness
	var sadnessStrats = ["Eat ice cream", "Watch Spongebob"];

	//Coping strategies for surprise
	var surpriseStrats = ["Speak with a friend about your current situation", "Watch television"];

	//An array of general coping strategies. Contains all coping strategies from above
	var generalStrats = angerStrats.concat(disgustStrats, fearStrats, happinessStrats, sadnessStrats, surpriseStrats);

	//Returns an array of coping strategies for the user's latest mood
	function getSpecificStrategies() {
		//Select coping strategies that match the latest mood
		switch (latestMoodLog.mood) {
			//If mood is angry
			case 0:
				return angerStrats;
				break;
			//If mood is disgust
			case 1:
				return disgustStrats;
				break;
			//If mood is fear
			case 2:
				return fearStrats;
				break;
			//If mood is happiness
			case 3:
				return happinessStrats;
				break;
			//If mood is sadness
			case 4:
				return sadnessStrats;
				break;
			//If mood is surprise
			case 5:
				return surpriseStrats;
				break;
			default:
				return generalStrats;
		}
	}

	//Returns an array of coping strategies that have worked in the past
	function getGoodStrategies() {
		var filtered = [];
		allFeedback.forEach(function (feedback) {
			//If the user thought a coping strategy was good in the past, redisplay the coping strategy
			if (feedback.response === 1) {
				filtered.push(feedback.copingStrategy);
			}
		});
		return filtered;
	}

	//Return general coping strategies, specific coping strategies, and coping strategies that have worked in the past
	return {
		generalStrategies: generalStrats,
		specificStrategies: getSpecificStrategies,
		pastStrategies: getGoodStrategies
	};
});
'use strict';

angular.module('starter.services', []).factory('Chats', function () {
  // Might use a resource here that returns a JSON array

  // Some fake testing data
  var chats = [{
    id: 0,
    name: 'Ben Sparrow',
    lastText: 'You on your way?',
    face: 'img/ben.png'
  }, {
    id: 1,
    name: 'Max Lynx',
    lastText: 'Hey, it\'s me',
    face: 'img/max.png'
  }, {
    id: 2,
    name: 'Adam Bradleyson',
    lastText: 'I should buy a boat',
    face: 'img/adam.jpg'
  }, {
    id: 3,
    name: 'Perry Governor',
    lastText: 'Look at my mukluks!',
    face: 'img/perry.png'
  }, {
    id: 4,
    name: 'Mike Harrington',
    lastText: 'This is wicked good ice cream.',
    face: 'img/mike.png'
  }];

  return {
    all: function all() {
      return chats;
    },
    remove: function remove(chat) {
      chats.splice(chats.indexOf(chat), 1);
    },
    get: function get(chatId) {
      for (var i = 0; i < chats.length; i++) {
        if (chats[i].id === parseInt(chatId)) {
          return chats[i];
        }
      }
      return null;
    }
  };
});
'use strict';

angular.module('starter.services', []).service('TrackProgressService', function () {
  var moods = [{
    id: 0,
    moodType: 'Happiness',
    intensity: 5,
    date: '2016-01-01'
  }, {
    id: 0,
    moodType: 'Anger',
    intensity: 3,
    date: '2016-02-02'
  }];
  return {
    all: function all() {
      return moods;
    },
    get: function get(type) {
      for (var i = 0; i < chats.length; i++) {
        if (moods[i].moodType === type) {
          return moods[i];
        }
      }
      return null;
    }
  };
}).services('ProgressDetailService', function (mood) {});
'use strict';

/* jshint esversion:6 */
angular.module('starter.services', []).service('Update Patterns', function () {

  // Change me! eventually...
  var learningRate = 1;

  // Dummy Constructor
  function ThetaRow(key, word, happy_trigger_theta, sad_trigger_theta, happy_belief_theta, sad_belief_theta, happy_behavior_theta, sad_behavior_theta) {
    this.key = key;
    this.word = word;
    this.happy_trigger_theta = happy_trigger_theta;
    this.sad_trigger_theta = sad_trigger_theta;
    this.happy_belief_theta = happy_trigger_theta;
    this.sad_belief_theta = sad_trigger_theta;
    this.happy_behavior_theta = happy_trigger_theta;
    this.sad_behavior_theta = sad_trigger_theta;
  }

  // Dummy Data
  /*var theta_table = [
    new ThetaRow(0, 'exam', 0.1, 0.9, 0.1, 0.9, 0.1, 0.9),
    new ThetaRow(1, 'icecream', 0.9, 0.1, 0.9, 0.1, 0.9, 0.1)
  ];*/

  var theta_table = [];

  // Dummy calls
  var database = {};
  database.get_view_patterns_key_by_word = function (word) {
    'use strict';

    var result = theta_table.filter(function (row) {
      return row.word === word;
    })[0];
    if (result) return new Promise(function (resolve, reject) {
      return resolve(result.key);
    });else {
      theta_table.push(new ThetaRow(theta_table.length, word, 0, 0, 0, 0, 0, 0));
      return new Promise(function (resolve, reject) {
        return resolve(theta_table.length - 1);
      });
    }
  };

  database.get_view_patterns_size = function () {
    return new Promise(function (resolve, reject) {
      return resolve(theta_table.length);
    });
  };

  database.set_theta = function (key, mood, theta) {
    return new Promise(function (resolve, reject) {
      if (key / theta_table.length < 1) {
        if (mood === 'happy') theta_table[key].happy_trigger_theta = theta;
        if (mood === 'sad') theta_table[key].sad_trigger_theta = theta;
      } else if (key / theta_table.length < 2) {
        if (mood === 'happy') theta_table[key % theta_table.length].happy_belief_theta = theta;
        if (mood === 'sad') theta_table[key % theta_table.length].sad_belief_theta = theta;
      } else if (key / theta_table.length < 3) {
        if (mood === 'happy') theta_table[key % theta_table.length].happy_behavior_theta = theta;
        if (mood === 'sad') theta_table[key % theta_table.length].sad_behavior_theta = theta;
      }
      resolve(theta);
    });
  };

  database.get_mood_thetas = function (mood) {
    if (mood === 'happy') return new Promise(function (resolve, reject) {
      return resolve(theta_table.map(function (row) {
        return row.happy_trigger_theta;
      }).concat(theta_table.map(function (row) {
        return row.happy_belief_theta;
      })).concat(theta_table.map(function (row) {
        return row.happy_behavior_theta;
      })));
    });else if (mood === 'sad') return new Promise(function (resolve, reject) {
      return resolve(theta_table.map(function (row) {
        return row.sad_trigger_theta;
      }).concat(theta_table.map(function (row) {
        return row.sad_belief_theta;
      })).concat(theta_table.map(function (row) {
        return row.sad_behavior_theta;
      })));
    });
  };

  database.get_mood_origin_thetas = function (mood, origin) {
    if (mood === 'happy') return new Promise(function (resolve, reject) {
      if (origin === 'trigger') resolve(theta_table.map(function (row) {
        return row.happy_trigger_theta;
      }));
      if (origin === 'belief') resolve(theta_table.map(function (row) {
        return row.happy_belief_theta;
      }));
      if (origin === 'behavior') resolve(theta_table.map(function (row) {
        return row.happy_behavior_theta;
      }));
    });else if (mood === 'sad') return new Promise(function (resolve, reject) {
      if (origin === 'trigger') resolve(theta_table.map(function (row) {
        return row.sad_trigger_theta;
      }));
      if (origin === 'belief') resolve(theta_table.map(function (row) {
        return row.sad_belief_theta;
      }));
      if (origin === 'behavior') resolve(theta_table.map(function (row) {
        return row.sad_behavior_theta;
      }));
    });
  };

  // End of dummy calls

  function stopFilter(arr) {
    var stopwords = ["a", "about", "above", "after", "again", "against", "all", "am", "an", "and", "any", "are", "aren't", "as", "at", "be", "because", "been", "before", "being", "below", "between", "both", "but", "by", "can't", "cannot", "could", "couldn't", "did", "didn't", "do", "does", "doesn't", "doing", "don't", "down", "during", "each", "few", "for", "from", "further", "had", "hadn't", "has", "hasn't", "have", "haven't", "having", "he", "he'd", "he'll", "he's", "her", "here", "here's", "hers", "herself", "him", "himself", "his", "how", "how's", "i", "i'd", "i'll", "i'm", "i've", "if", "in", "into", "is", "isn't", "it", "it's", "its", "itself", "let's", "me", "more", "most", "mustn't", "my", "myself", "no", "nor", "not", "of", "off", "on", "once", "only", "or", "other", "ought", "our", "ours	ourselves", "out", "over", "own", "same", "shan't", "she", "she'd", "she'll", "she's", "should", "shouldn't", "so", "some", "such", "than", "that", "that's", "the", "their", "theirs", "them", "themselves", "then", "there", "there's", "these", "they", "they'd", "they'll", "they're", "they've", "this", "those", "through", "to", "too", "under", "until", "up", "very", "was", "wasn't", "we", "we'd", "we'll", "we're", "we've", "were", "weren't", "what", "what's", "when", "when's", "where", "where's", "which", "while", "who", "who's", "whom", "why", "why's", "with", "won't", "would", "wouldn't", "you", "you'd", "you'll", "you're", "you've", "your", "yours", "yourself", "yourselves"];
    var myStopwords = ["will"];
    stopwords = stopwords.concat(myStopwords);
    var filtered = [];
    arr.forEach(function (word) {
      if (stopwords.indexOf(word) === -1) filtered.push(word);
    });
    return filtered;
  }

  function rawText(str) {
    return str.slice(0).replace(/[^\w\s]|_/g, "").replace(/\s+/g, " ").toLowerCase();
  }

  function featureVector(arr) {
    return Promise.all(arr.map(function (word) {
      return database.get_view_patterns_key_by_word(word);
    })).then(function (mapped) {
      return [mapped, database.get_view_patterns_size()];
    }).then(function (spoils) {
      return spoils[1].then(function (size) {
        var vector = Array.apply(null, Array(size)).map(Number.prototype.valueOf, 0);
        spoils[0].forEach(function (key) {
          return vector[key] = 1;
        });
        return vector;
      });
    });
  }

  function sigmoid(x) {
    return 1.0 / (1.0 + Math.exp(-x));
  }

  function predict(x, theta) {
    // Make sure to import numeric somehow
    return sigmoid(numeric.dot(x, theta));
  }

  function gradientDescent(mood, x, y, alpha) {
    return database.get_mood_thetas(mood).then(function (thetas) {
      var promises = [];
      thetas.forEach(function (theta, i) {
        return promises.push(database.set_theta(i, mood, theta - (predict(x, thetas) - y) * x[i]));
      });
      return Promise.all(promises);
    });
  }

  function even(arr) {
    'use strict';

    arr.sort(function (a, b) {
      return a.length > b.length;
    });
    for (var i = arr.length - 2; i >= 0; i--) {
      while (arr[i].length < arr[i + 1].length) {
        arr[i].push(0);
      }
    }
    return arr;
  }

  function masterVector(moodLog) {
    return featureVector(stopFilter(rawText(moodLog.trigger).split(" "))).then(function (trigger) {
      return featureVector(stopFilter(rawText(moodLog.belief).split(" "))).then(function (belief) {
        return featureVector(stopFilter(rawText(moodLog.behavior).split(" "))).then(function (behavior) {
          return even([trigger, belief, behavior]).reduce(function (a, b) {
            return a.concat(b);
          });
        });
      });
    });
  }

  return {
    update: function update(moodLog) {
      return masterVector(moodLog).then(function (x) {
        return gradientDescent(moodLog.mood, x, moodLog.intensity / 10, learningRate);
      });
    }
  };
});
'use strict';

/* jshint esversion:6 */
angular.module('starter.services', []).service('View Patterns', function () {

  // Constructor for pattern objects, might delete
  function Pattern(keyword, origin, mood, intensity) {
    this.keyword = keyword;
    this.origin = origin;
    this.mood = mood;
    this.intensity = intensity;
  }

  // Dummy pattern data
  var patterns = [new Pattern('exam', 'belief', 'stressed', 0.9), new Pattern('chocolate', 'behavior', 'happy', 0.7)];

  // Dummy calls
  var database = {};

  database.get_pattern_cache = function () {
    return new Promise(function (resolve, reject) {
      return resolve(patterns);
    });
  };

  return {
    all: function all() {
      return database.get_pattern_cache();
    }
  };
});