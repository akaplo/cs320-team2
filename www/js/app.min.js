'use strict';

// Ionic Starter App

// angular.module is a global place for creating, registering and retrieving Angular modules
// 'starter' is the name of this angular module example (also set in a <body> attribute in index.html)
// the 2nd parameter is an array of 'requires'
// 'starter.services' is found in services.js
// 'starter.controllers' is found in controllers.js
var app = angular.module('starter', ['ionic', 'ngCordova']).run(function ($ionicPlatform) {
  $ionicPlatform.ready(function () {
    // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
    // for form inputs)
    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
      cordova.plugins.Keyboard.disableScroll(true);
    }
    if (window.StatusBar) {
      // org.apache.cordova.statusbar required
      StatusBar.styleDefault();
    }
  });
}).config(function ($stateProvider, $urlRouterProvider) {

  // Ionic uses AngularUI Router which uses the concept of states
  // Learn more here: https://github.com/angular-ui/ui-router
  // Set up the various states which the app can be in.
  // Each state's controller can be found in controllers.js
  $stateProvider

  // setup an abstract state for the tabs directive
  .state('tab', {
    url: '/tab',
    abstract: true,
    templateUrl: 'templates/tabs.html'
  })

  // Each tab has its own nav history stack:

  .state('tab.dash', {
    url: '/dash',
    views: {
      'tab-dash': {
        templateUrl: 'templates/tab-dash.html',
        controller: 'DashCtrl'
      }
    }
  }).state('tab.chats', {
    url: '/chats',
    views: {
      'tab-chats': {
        templateUrl: 'templates/tab-chats.html',
        controller: 'ChatsCtrl'
      }
    }
  }).state('tab.chat-detail', {
    url: '/chats/:chatId',
    views: {
      'tab-chats': {
        templateUrl: 'templates/chat-detail.html',
        controller: 'ChatDetailCtrl'
      }
    }
  }).state('tab.account', {
    url: '/account',
    views: {
      'tab-account': {
        templateUrl: 'templates/tab-account.html',
        controller: 'AccountCtrl'
      }
    }
  });

  // if none of the above states are matched, use this as the fallback
  $urlRouterProvider.otherwise('/tab/dash');
});
'use strict';

app.controller('DashCtrl', function ($scope, sqlService, $ionicPlatform) {
  $ionicPlatform.ready(function () {
    console.log("ionicPlatform ready");

    // initialize database
    sqlService.init().then(function (res) {
      // run a view query
      sqlService.viewTable('mood_logs').then(function (result) {
        return console.log("View result", result.rows.item(0));
      }, function (err) {
        return console.log("View error", err);
      });

      sqlService.executeQuery('SELECT * FROM mood_logs').then(function (result) {
        return console.log("Query result", result.rows.item(0));
      }, function (err) {
        return console.log("Query error", err);
      });
    }, function (err) {
      return console.log(err);
    });
  });
});

app.controller('ChatsCtrl', function ($scope, Chats, sqlService, $ionicPlatform) {
  // With the new view caching in Ionic, Controllers are only called
  // when they are recreated or on app start, instead of every page change.
  // To listen for when this page is active (for example, to refresh data),
  // listen for the $ionicView.enter event:
  //
  //$scope.$on('$ionicView.enter', function(e) {
  //});

  $scope.chats = Chats.all();
  $scope.remove = function (chat) {
    Chats.remove(chat);
  };
});

app.controller('ChatDetailCtrl', function ($scope, $stateParams, Chats) {
  $scope.chat = Chats.get($stateParams.chatId);
});

app.controller('AccountCtrl', function ($scope) {
  $scope.settings = {
    enableFriends: true
  };
});
'use strict';

app.factory('Chats', function () {
  // Might use a resource here that returns a JSON array

  // Some fake testing data
  var chats = [{
    id: 0,
    name: 'Ben Sparrow',
    lastText: 'You on your way?',
    face: 'img/ben.png'
  }, {
    id: 1,
    name: 'Max Lynx',
    lastText: 'Hey, it\'s me',
    face: 'img/max.png'
  }, {
    id: 2,
    name: 'Adam Bradleyson',
    lastText: 'I should buy a boat',
    face: 'img/adam.jpg'
  }, {
    id: 3,
    name: 'Perry Governor',
    lastText: 'Look at my mukluks!',
    face: 'img/perry.png'
  }, {
    id: 4,
    name: 'Mike Harrington',
    lastText: 'This is wicked good ice cream.',
    face: 'img/mike.png'
  }];

  return {
    all: function all() {
      return chats;
    },
    remove: function remove(chat) {
      chats.splice(chats.indexOf(chat), 1);
    },
    get: function get(chatId) {
      for (var i = 0; i < chats.length; i++) {
        if (chats[i].id === parseInt(chatId)) {
          return chats[i];
        }
      }
      return null;
    }
  };
});
"use strict";

/* jshint esversion:6 */
app.service('Update Patterns', function () {

  function stopFilter(arr) {
    var stopwords = ["a", "about", "above", "after", "again", "against", "all", "am", "an", "and", "any", "are", "aren't", "as", "at", "be", "because", "been", "before", "being", "below", "between", "both", "but", "by", "can't", "cannot", "could", "couldn't", "did", "didn't", "do", "does", "doesn't", "doing", "don't", "down", "during", "each", "few", "for", "from", "further", "had", "hadn't", "has", "hasn't", "have", "haven't", "having", "he", "he'd", "he'll", "he's", "her", "here", "here's", "hers", "herself", "him", "himself", "his", "how", "how's", "i", "i'd", "i'll", "i'm", "i've", "if", "in", "into", "is", "isn't", "it", "it's", "its", "itself", "let's", "me", "more", "most", "mustn't", "my", "myself", "no", "nor", "not", "of", "off", "on", "once", "only", "or", "other", "ought", "our", "ours	ourselves", "out", "over", "own", "same", "shan't", "she", "she'd", "she'll", "she's", "should", "shouldn't", "so", "some", "such", "than", "that", "that's", "the", "their", "theirs", "them", "themselves", "then", "there", "there's", "these", "they", "they'd", "they'll", "they're", "they've", "this", "those", "through", "to", "too", "under", "until", "up", "very", "was", "wasn't", "we", "we'd", "we'll", "we're", "we've", "were", "weren't", "what", "what's", "when", "when's", "where", "where's", "which", "while", "who", "who's", "whom", "why", "why's", "with", "won't", "would", "wouldn't", "you", "you'd", "you'll", "you're", "you've", "your", "yours", "yourself", "yourselves"];
    var filtered = [];
    arr.forEach(function (word) {
      if (stopwords.indexOf(word) === -1) filtered.push(word);
    });
    return filtered;
  }

  function featureVector(arr) {
    var mapping = [];
  }

  return {
    update: function update(moodLog) {
      moodLog.belief = stopFilter(moodLog.belief.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " ").toLowerCase().split(" "));
      moodLog.behavior = stopFilter(moodLog.behavior.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " ").toLowerCase().split(" "));
      moodLog.trigger = stopFilter(moodLog.trigger.replace(/[^\w\s]|_/g, "").replace(/\s+/g, " ").toLowerCase().split(" "));
    }
  };
});
'use strict';

app.service('View Patterns', function () {

  // Constructor for pattern objects, might delete
  function Pattern(keyword, origin, mood, intensity) {
    this.keyword = keyword;
    this.origin = origin;
    this.mood = mood;
    this.intensity = intensity;
  }

  // Dummy pattern data
  var patterns = [new Pattern('exam', 'belief', 'stressed', 0.9), new Pattern('chocolate', 'behavior', 'happy', 0.7)];

  return {
    all: function all() {
      return patterns;
    }
  };
});
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* jshint esversion:6 */
app.factory('sqlService', function ($cordovaSQLite) {
	//define db instance
	var service = {},
	    db = null;

	var popQrys = {};
	popQrys.mood_logs = ['DROP TABLE IF EXISTS mood_logs', 'CREATE TABLE mood_logs(id INTEGER PRIMARY KEY NOT NULL,message TEXT NOT NULL)'];
	popQrys.pattern_features = ['DROP TABLE IF EXISTS pattern_features', 'CREATE TABLE pattern_features(\
		id INTEGER PRIMARY KEY NOT NULL,\
		word TEXT NOT NULL UNIQUE,\
		happy_trigger_theta REAL NOT NULL DEFAULT 0,\
		stressed_trigger_theta REAL NOT NULL DEFAULT 0,\
		happy_belief_theta REAL NOT NULL DEFAULT 0,\
		stressed_belief_theta REAL NOT NULL DEFAULT 0,\
		happy_behavior_theta REAL NOT NULL DEFAULT 0,\
		stressed_behavior_theta REAL NOT NULL DEFAULT 0)'];

	var populate = function populate() {
		return new Promise(function (resolve, reject) {
			if (db === null) reject("DB connection not initiated. Call init() before running queries.");

			db.sqlBatch([].concat(_toConsumableArray(popQrys.pattern_features), _toConsumableArray(popQrys.mood_logs)), function (error) {
				if (error) reject(error);
				db.executeSql('INSERT INTO mood_logs (message) VALUES (?)', ['this is a mood log blah blah blah'], function (resultSet) {
					resolve();
				}, function (error) {
					return reject(error);
				});
			}, function (error) {
				console.log('Populate table error: ' + error.message);
				reject(error);
			});
		});
	};

	/* 
 ** Opens a database connection and populates it with our data schemas
 ** Returns: Promise sucess(resultSet), error(error)
 */
	service.init = function () {
		return new Promise(function (resolve, reject) {
			if (db === null) {
				console.log("DB not ready");
				//instantiate db with cordova
				db = window.sqlitePlugin.openDatabase({ name: 'moodlogger.db', location: 'default', androidLockWorkaround: 1 });
				populate().then(function (res) {
					return resolve(res);
				}, function (err) {
					return reject(err);
				});
			} else {
				console.log("DB ready");
				resolve();
			}
		});
	};

	/* 
 ** Returns all fields in a specified table
 ** Args: table ( name of a table, String )
 ** Returns: Promise sucess(resultSet), error(error)
 */
	service.viewTable = function (table) {
		return new Promise(function (resolve, reject) {
			if (db === null) reject("DB connection not initiated. Call init() before running queries.");

			db.executeSql('SELECT * FROM ' + table, [], function (resultSet) {
				resolve(resultSet);
			}, function (error) {
				return reject(error);
			});
		});
	};

	/* 
 ** Executes query and returns result or an error object
 ** Args: qry ( an SQL query, String )
 ** Returns: Promise sucess(resultSet), error(error)
 */
	service.executeQuery = function (qry) {
		return new Promise(function (resolve, reject) {
			if (db === null) reject("DB connection not initiated. Call init() before running queries.");

			db.executeSql(qry, [], function (resultSet) {
				resolve(resultSet);
			}, function (error) {
				return reject(error);
			});
		});
	};

	return service;
});